#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage: icloud-calendar-sync [--cache] [--cache-file <path>]

Sync iCloud CalDAV calendars into local vdirs with vdirsyncer.

Options:
  --cache              Write normalized events cache JSON to the default path.
  --cache-file <path>  Write normalized events cache JSON to a custom path.
  -h, --help           Show this help.
USAGE
}

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"

ENV_FILES=(
  "$ROOT_DIR/.env.icloud-calendar"
  "$XDG_CONFIG_HOME/icloud-calendar.env"
)

write_cache=0
cache_file=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --cache)
      write_cache=1
      ;;
    --cache-file)
      if [ "$#" -lt 2 ]; then
        echo "error: --cache-file requires a path" >&2
        exit 1
      fi
      write_cache=1
      cache_file="$2"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "error: unknown option: $1" >&2
      usage >&2
      exit 1
      ;;
  esac
  shift
done

for env_file in "${ENV_FILES[@]}"; do
  if [ -f "$env_file" ]; then
    set -a
    # shellcheck disable=SC1090
    . "$env_file"
    set +a
  fi
done

if [ -z "${ICLOUD_CALDAV_USERNAME:-}" ]; then
  echo "error: ICLOUD_CALDAV_USERNAME is required" >&2
  echo "hint: define it in ~/.config/icloud-calendar.env or $ROOT_DIR/.env.icloud-calendar" >&2
  exit 1
fi

if [ -z "${ICLOUD_CALDAV_APP_PASSWORD:-}" ]; then
  echo "error: ICLOUD_CALDAV_APP_PASSWORD is required" >&2
  echo "hint: use an Apple app-specific password" >&2
  exit 1
fi

if [ -z "$cache_file" ]; then
  cache_file="$XDG_CACHE_HOME/icloud-calendar/events.json"
fi

caldav_url="${ICLOUD_CALDAV_URL:-https://caldav.icloud.com/}"
calendar_tz="${ICLOUD_CALENDAR_TIMEZONE:-UTC}"

calendar_root="$XDG_DATA_HOME/calendars/icloud"
vdir_dir="$calendar_root/vdirs"
status_dir="$XDG_STATE_HOME/icloud-calendar/vdirsyncer"
khal_config="$XDG_CONFIG_HOME/khal/config"

mkdir -p "$vdir_dir" "$status_dir"

if [ ! -f "$khal_config" ]; then
  mkdir -p "$(dirname "$khal_config")"
  cat > "$khal_config" <<KHAL
[calendars]
[[icloud]]
path = $vdir_dir/*
type = discover

[locale]
local_timezone = $calendar_tz
default_timezone = $calendar_tz
timeformat = %H:%M
dateformat = %Y-%m-%d
longdateformat = %Y-%m-%d
datetimeformat = %Y-%m-%d %H:%M
longdatetimeformat = %Y-%m-%d %H:%M
KHAL
fi

escape_vdirsyncer() {
  printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'
}

username_escaped="$(escape_vdirsyncer "$ICLOUD_CALDAV_USERNAME")"
password_escaped="$(escape_vdirsyncer "$ICLOUD_CALDAV_APP_PASSWORD")"
url_escaped="$(escape_vdirsyncer "$caldav_url")"
status_escaped="$(escape_vdirsyncer "$status_dir")"
path_escaped="$(escape_vdirsyncer "$vdir_dir")"

vdirsyncer_config="$(mktemp)"
trap 'rm -f "$vdirsyncer_config"' EXIT

cat > "$vdirsyncer_config" <<VDIRSYNCER
[general]
status_path = "$status_escaped/"

[pair icloud_calendar]
a = "icloud_local"
b = "icloud_remote"
collections = ["from b"]
conflict_resolution = "b wins"
metadata = ["displayname", "color"]

[storage icloud_local]
type = "filesystem"
path = "$path_escaped/"
fileext = ".ics"

[storage icloud_remote]
type = "caldav"
url = "$url_escaped"
username = "$username_escaped"
password = "$password_escaped"
VDIRSYNCER

if [ -z "$(ls -A "$status_dir" 2>/dev/null || true)" ]; then
  vdirsyncer -c "$vdirsyncer_config" discover
fi

vdirsyncer -c "$vdirsyncer_config" sync

if [ "$write_cache" -eq 1 ]; then
  mkdir -p "$(dirname "$cache_file")"
  python3 - "$vdir_dir" "$cache_file" <<'PY'
import json
import os
import re
import sys
from datetime import datetime, timezone

root = sys.argv[1]
out = sys.argv[2]


def unfold_lines(text: str):
    result = []
    for line in text.splitlines():
        if line.startswith((" ", "\t")) and result:
            result[-1] += line[1:]
        else:
            result.append(line)
    return result


def parse_property(line: str):
    if ":" not in line:
        return None, None, {}
    left, value = line.split(":", 1)
    parts = left.split(";")
    name = parts[0]
    params = {}
    for param in parts[1:]:
        if "=" in param:
            k, v = param.split("=", 1)
            params[k.upper()] = v
    return name.upper(), value, params


def normalize_ical_dt(raw: str):
    if re.fullmatch(r"\d{8}", raw):
        return f"{raw[0:4]}-{raw[4:6]}-{raw[6:8]}"
    m = re.fullmatch(r"(\d{8})T(\d{6})(Z?)", raw)
    if not m:
        return raw
    date_part, time_part, z = m.groups()
    normalized = (
        f"{date_part[0:4]}-{date_part[4:6]}-{date_part[6:8]}"
        f"T{time_part[0:2]}:{time_part[2:4]}:{time_part[4:6]}"
    )
    return normalized + ("Z" if z else "")


records = []
for dirpath, _, filenames in os.walk(root):
    for filename in filenames:
        if not filename.endswith(".ics"):
            continue
        ics_path = os.path.join(dirpath, filename)
        rel = os.path.relpath(ics_path, root)
        calendar = rel.split(os.sep, 1)[0]

        with open(ics_path, "r", encoding="utf-8", errors="replace") as f:
            lines = unfold_lines(f.read())

        in_event = False
        event = {}

        for line in lines:
            if line == "BEGIN:VEVENT":
                in_event = True
                event = {
                    "path": rel,
                    "calendar": calendar,
                    "uid": "",
                    "summary": "",
                    "start": "",
                    "end": "",
                    "start_type": "datetime",
                    "end_type": "datetime",
                    "start_tz": "",
                    "end_tz": "",
                    "last_modified": "",
                }
                continue

            if line == "END:VEVENT":
                in_event = False
                records.append(event)
                event = {}
                continue

            if not in_event:
                continue

            name, value, params = parse_property(line)
            if name is None:
                continue

            if name == "UID":
                event["uid"] = value
            elif name == "SUMMARY":
                event["summary"] = value
            elif name == "DTSTART":
                event["start"] = normalize_ical_dt(value)
                event["start_type"] = "date" if params.get("VALUE") == "DATE" else "datetime"
                event["start_tz"] = params.get("TZID", "")
            elif name == "DTEND":
                event["end"] = normalize_ical_dt(value)
                event["end_type"] = "date" if params.get("VALUE") == "DATE" else "datetime"
                event["end_tz"] = params.get("TZID", "")
            elif name == "LAST-MODIFIED":
                event["last_modified"] = normalize_ical_dt(value)

records.sort(key=lambda r: (r.get("start", ""), r.get("uid", ""), r.get("path", "")))

payload = {
    "generated_at": datetime.now(timezone.utc).isoformat(),
    "source": root,
    "count": len(records),
    "events": records,
}

with open(out, "w", encoding="utf-8") as f:
    json.dump(payload, f, indent=2, sort_keys=False)
    f.write("\n")
PY

  echo "cache written: $cache_file"
fi

echo "sync complete"
